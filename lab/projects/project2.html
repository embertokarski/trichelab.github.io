<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Welcome to the Lab</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
	    <!-- Static navbar -->
    <nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Triche Lab</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#">Home</a></li>
            <li><a href="#">People</a></li>
            <li><a href="#">Projects</a></li>
			<li><a href="#">Publications</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">In the Lab<span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="#">Welcome to the Lab</a></li>
                <li><a href="#">Onboarding</a></li>
                <li role="separator" class="divider"></li>
                <li class="dropdown-header">Practical Sessions</li>
                <li class="active"><a href="#">Part 1</a></li>
                <li><a href="#">Part 2: scRNA</a></li>
				<li><a href="#">Project 2: Tim's stab at it</a></li>
              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>
  


    <div class="container">

		<div class="starter-template">
			<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Practical sessions part 2: scRNA</h1>
  </header>

    <div class="post-content">
    <h1 id="installation">Installation</h1>

		<p>Install the ExpDesign2021 package from github, if you haven’t already.
		If you’re knitting this on your own machine, you will want to load knitr too.</p>

		<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#install.packages("remotes")</span><span class="w">
		</span><span class="c1">#install.packages("BiocManager")</span><span class="w">
		</span><span class="c1">#BiocManager::install("VanAndelInstitute/ExpDesign2021")</span><span class="w">
		</span><span class="n">library</span><span class="p">(</span><span class="n">knitr</span><span class="p">)</span><span class="w">
		</span></code></pre></div></div>

		<p>To extract just the R code, you can use knitr::knit(input, tangle=TRUE):</p>

		<h1 id="introduction">Introduction</h1>

		<p><img src="./figure/scRNAseq.jpg" alt="representative scRNA plots" /></p>

		<p><em>Extra credit assignment: figure out whose lab the above came from</em></p>

		<details>
		  <summary>Click for hint</summary>
		  They're at the Gladstone Institute now, if memory serves. 
		</details>

		<p>For project 2 (“design your own damned experiment”), the class boldly rallied 
		behind Richard Cassidy’s suggestion of using single-cell RNA-seq data for an 
		example dataset. This seemed like a great idea: it’s big, it’s messy, and it 
		accompanies a <a href="https://www.nature.com/articles/s41587-020-0465-8">glam paper for a blue-collar experiment</a>, which is kind of cool. (The paper also covers 
		single-cell vs. single-nucleus RNAseq comparisons, but we won’t go there yet.)
		The cell mixture model (HEK293 human cells and NIH3T3 mouse cells) is straight-
		forward (mix two types of cells in two test tubes and then split).</p>

		<h1 id="the-broad-institute-barnyard-data">The Broad Institute barnyard data</h1>

		<p><em>Question: why is it called a ‘barnyard’ experiment?</em></p>
		<details>
		  <summary>Click for Answer</summary>
		  A traditional test of single-cell protocols is to mix cells from two species,
		  and then see if the results can be easily classified into one or the other. 
		  A protocol which does a good job of encapsulating cells will make it easier
		  to classify each cell by species. Some 'barnyard' experiments have tossed in 
		  canine or chicken cells for variety, but since it's such a common benchmark,
		  people took to calling any species-mixing single-cell experiment a 'barnyard' 
		  experiment, and the name stuck. 
		</details>

		<p>The library preparation methods involved in the paper may bear explanation. 
		Short-read RNA sequencing experiments require cDNA as their input, since most
		sequencers expect to call bases from DNA; as a consequence, one must first make
		libraries of cDNA molecules from fragmented mRNA. Numerous approaches exist, 
		six of which are employed here.</p>

		<p><img src="./figure/methods.png" alt="methods compared" /></p>

		<p><a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE132044">The data is available from GEO</a> although it’s a bit unwieldy, weighing in at 300MB for the cell
		mixture model counts alone. Happily, we can load up the metadata without that.</p>

		<p><img src="./figure/bustools.jpeg" alt="bus format" /></p>

		<p>The barcode, UMI, set or <a href="https://academic.oup.com/bioinformatics/article/35/21/4472/5487510">BUS format</a> neatly encapsulates the process of transforming reads
		resulting from a single-cell RNAseq experiment into counts of molecular barcodes
		describing a cell, a molecule, and the likely genomic origin of that molecule.
		It’s one of the most compact representations possible for raw scRNAseq outputs, 
		and the figure shows how it facilitates direct comparisons. The Broad used their
		<code class="language-plaintext highlighter-rouge">scumi</code> tool instead, but the basic notion (“make everything comparable”) and 
		the resulting sparse matrix of counts is similar in spirit.</p>

		<h2 id="cells">Cells</h2>

		<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
		</span><span class="c1"># read in the cell names for the count matrix directly from GEO </span><span class="w">
		</span><span class="n">cells</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readLines</span><span class="p">(</span><span class="n">gzcon</span><span class="p">(</span><span class="n">url</span><span class="p">(</span><span class="s2">"https://ftp.ncbi.nlm.nih.gov/geo/series/GSE132nnn/GSE132044/suppl/GSE132044_mixture_hg19_mm10_cell.tsv.gz"</span><span class="p">)))</span><span class="w">
		</span><span class="c1"># in English: "create a gzip connection from the URL at GEO, then read from it"</span><span class="w">

		</span><span class="c1"># tidy things up </span><span class="w">
		</span><span class="n">library</span><span class="p">(</span><span class="n">stringr</span><span class="p">)</span><span class="w">
		</span><span class="n">library</span><span class="p">(</span><span class="n">tidyverse</span><span class="p">)</span><span class="w">

		</span><span class="c1"># now decode the metadata from it</span><span class="w">
		</span><span class="n">tibble</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cells</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="c1"># stringr::str_split takes strings and a split pattern</span><span class="w">
		  </span><span class="n">mutate</span><span class="p">(</span><span class="n">experiment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_split</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="s2">"\\."</span><span class="p">,</span><span class="w"> </span><span class="n">simplify</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)[,</span><span class="m">1</span><span class="p">])</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="c1"># column 1</span><span class="w">
		  </span><span class="n">mutate</span><span class="p">(</span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_split</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="s2">"\\."</span><span class="p">,</span><span class="w"> </span><span class="n">simplify</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)[,</span><span class="m">2</span><span class="p">])</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="c1"># column 2 </span><span class="w">
		  </span><span class="n">mutate</span><span class="p">(</span><span class="n">cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_split</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="s2">"\\."</span><span class="p">,</span><span class="w"> </span><span class="n">simplify</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)[,</span><span class="m">3</span><span class="p">])</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="c1"># column 3</span><span class="w">
			</span><span class="n">celltibble</span><span class="w"> </span><span class="c1"># the result is assigned to the object `celltibble`</span><span class="w">

		</span><span class="c1"># how many cells per mixture were run with each method?</span><span class="w">
		</span><span class="n">with</span><span class="p">(</span><span class="n">celltibble</span><span class="p">,</span><span class="w"> 
			 </span><span class="n">table</span><span class="p">(</span><span class="n">method</span><span class="p">,</span><span class="w"> </span><span class="n">experiment</span><span class="p">))</span><span class="w">
		</span><span class="c1">#&gt;                  experiment</span><span class="w">
		</span><span class="c1">#&gt; method            Mixture1 Mixture2</span><span class="w">
		</span><span class="c1">#&gt;   10x-Chromium-v2     3159     3187</span><span class="w">
		</span><span class="c1">#&gt;   CEL-Seq2             359      347</span><span class="w">
		</span><span class="c1">#&gt;   Drop-seq            2594     3812</span><span class="w">
		</span><span class="c1">#&gt;   Seq-Well            1627     1012</span><span class="w">
		</span><span class="c1">#&gt;   Smart-seq2           342      343</span><span class="w">
		</span><span class="c1">#&gt;   inDrops             3081     2529</span><span class="w">
		</span><span class="c1">#&gt;   sci-RNA-seq          299     5023</span><span class="w">
		</span></code></pre></div></div>

		<p>Arguably, we don’t need more than (say) 300 cells per method for this exercise,
		and it would be nice not to demolish your computers’ RAM (even though we’re not
		using Seurat or some piggish monstrosity like that). So we’ll probably chop down
		the number of cells from which you resample, at least for this project. If you
		are familiar with block resampling, you already know where this is going.</p>

		<h2 id="genes">Genes</h2>

		<p>We can do the same type of thing for the genes involved, albeit without the 
		intention of chopping them down by much if at all:</p>

		<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
		</span><span class="c1"># read in the gene names for the count matrix directly from GEO </span><span class="w">
		</span><span class="n">genes</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readLines</span><span class="p">(</span><span class="n">gzcon</span><span class="p">(</span><span class="n">url</span><span class="p">(</span><span class="s2">"https://ftp.ncbi.nlm.nih.gov/geo/series/GSE132nnn/GSE132044/suppl/GSE132044_mixture_hg19_mm10_gene.tsv.gz"</span><span class="p">)))</span><span class="w">
		</span><span class="c1"># in English: "create a gzip connection from the URL at GEO, then read from it"</span><span class="w">

		</span><span class="c1"># tidy things up </span><span class="w">
		</span><span class="n">library</span><span class="p">(</span><span class="n">stringr</span><span class="p">)</span><span class="w">
		</span><span class="n">library</span><span class="p">(</span><span class="n">tidyverse</span><span class="p">)</span><span class="w">

		</span><span class="c1"># now decode the metadata from it</span><span class="w">
		</span><span class="n">tibble</span><span class="p">(</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">genes</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">  </span><span class="c1"># stringr::str_split(string, pattern_to_split_on)</span><span class="w">
		  </span><span class="n">mutate</span><span class="p">(</span><span class="n">ensembl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_split</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="s2">"_"</span><span class="p">,</span><span class="w"> </span><span class="n">simplify</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)[,</span><span class="m">2</span><span class="p">])</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="c1"># ENS[MUS]G name</span><span class="w">
		  </span><span class="n">mutate</span><span class="p">(</span><span class="n">genome</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str_split</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="s2">"_"</span><span class="p">,</span><span class="w"> </span><span class="n">simplify</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)[,</span><span class="m">3</span><span class="p">])</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="c1"># genome assembly</span><span class="w">
			</span><span class="n">genetibble</span><span class="w"> </span><span class="c1"># assign the result to `genetibble` </span><span class="w">

		</span><span class="c1"># how many genes per assembly? </span><span class="w">
		</span><span class="n">with</span><span class="p">(</span><span class="n">genetibble</span><span class="p">,</span><span class="w"> </span><span class="n">table</span><span class="p">(</span><span class="n">genome</span><span class="p">))</span><span class="w">
		</span><span class="c1">#&gt; genome</span><span class="w">
		</span><span class="c1">#&gt;  hg19  mm10 </span><span class="w">
		</span><span class="c1">#&gt; 33354 28692</span><span class="w">
		</span></code></pre></div></div>

		<p><em>Question: why didn’t we use the gene symbols in columns 4:6?</em></p>
		<details>
		  <summary>Click for Answer</summary>
		  Because some ENSEMBL gene names map to multiple RefGene/HUGO symbols. 
		</details>

		<p>With the release of Bioconductor 3.14, the project includes a tidy single cell 
		experiment (data structure) package, which is great since all other single cell 
		data structures kind of suck. (No, seriously, you’ll find out why eventually.) 
		The package is, not coincidentally, called <a href="http://www.bioconductor.org/packages/release/bioc/vignettes/tidySingleCellExperiment/inst/doc/introduction.html">tidySingleCellExperiment</a>:</p>

		<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">require</span><span class="p">(</span><span class="s2">"tidySingleCellExperiment"</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
		  </span><span class="n">BiocManager</span><span class="o">::</span><span class="n">install</span><span class="p">(</span><span class="s2">"SingleCellExperiment"</span><span class="p">)</span><span class="w">
		  </span><span class="n">library</span><span class="p">(</span><span class="n">SingleCellExperiment</span><span class="p">)</span><span class="w">
		  </span><span class="n">BiocManager</span><span class="o">::</span><span class="n">install</span><span class="p">(</span><span class="s2">"tidySingleCellExperiment"</span><span class="p">)</span><span class="w">
		  </span><span class="n">library</span><span class="p">(</span><span class="n">tidySingleCellExperiment</span><span class="p">)</span><span class="w">
		</span><span class="p">}</span><span class="w">

		</span></code></pre></div></div>

		<h1 id="chopping-down-the-data-to-fit-in-ram">Chopping down the data to fit in RAM</h1>

		<p>Above, I stated that maybe we don’t need thousands of cells per method. 
		(This is arguable; in exchange for crappy per-cell results, 10X and similar
		offer more cells at the price of more dropouts and less sensitivity per cell.)
		No worries, we’ll just go ahead and downsample “enough” cells per method.
		It turns out this happens to me often enough that I wrote some code to do it:</p>

		<details>
		  <summary>Click for sample_umis() function code</summary>

		```r

		# adapted from a SingleCellExperiment-centric method for CITEseq
		sample_umis &lt;- function(umis, meta, block, ideal=300) {

		  stopifnot(nrow(meta) == ncol(umis))
		  stopifnot(length(block) == nrow(meta))

		  pops &lt;- sort(table(block))
		  samplesets &lt;- split(seq_len(nrow(meta)), block)

		  keep &lt;- integer()
		  for (set in names(samplesets)) {
			sset &lt;- samplesets[[set]]
			cells &lt;- length(sset)
			if (cells &lt;= ideal) {
			  pct &lt;- 100
			  keep &lt;- c(keep, sset)
			  message("Kept ", cells, " cells (", pct, "%) of type ", set, ".")
			} else {
			  kept &lt;- sample(sset, size=ideal)
			  pct &lt;- round((ideal / cells) * 100)
			  keep &lt;- c(keep, kept)
			  message("Kept ", ideal, " cells (", pct, "%) of type ", set, ".")
			}
		  }

		  pct &lt;- round((length(keep) / ncol(umis)) * 100, 1)
		  message("Kept ", length(keep), " (", pct, "%) of ", ncol(umis),
				  " cells in ", length(samplesets), " blocks.")
		  umis[, keep]

		}
		```
		</details>

		<p><em>Question: can you generate block-random samples from the metadata you have?</em></p>
		<details>
		  <summary>Click for answer</summary>
		  Easily, although you'd need to rewrite the above function to omit `umis`.
		</details>

		<p>It’s possible your machine or instance would crash if you did the following
		(apparently nobody told IT that a laptop is a device to take RAM on a plane). 
		I’m going to stick to the above “300 cells ought to be enough” and do this:</p>

		<details>
		  <summary>Click for gory details</summary>

		```r

		# pre-downloaded MatrixMarket file from GEO
		library(Matrix)

		if (FALSE) {

		  # put it into a column-sparse Matrix object to avoid wasting heaps of RAM
		  umi_counts &lt;- as(readMM("GSE132044_mixture_hg19_mm10_count_matrix.mtx.gz"), "dgCMatrix") # "read this as if it were already a column-sparse Matrix object"

		  # never trust anyone, including yourself 
		  stopifnot(nrow(umi_counts) == nrow(genetibble))
		  stopifnot(ncol(umi_counts) == nrow(celltibble))

		  # bolt the dimensions back onto the data
		  rownames(umi_counts) &lt;- genetibble$name
		  colnames(umi_counts) &lt;- celltibble$name

		  # create a basis for blocked downsampling
		  celltibble %&gt;%
			mutate(block = paste(method, experiment, sep="_")) -&gt; 
			  blocktibble 

		  # block downsample 
		  downsampled &lt;- sample_umis(umi_counts, blocktibble, blocktibble$block)
		  # Kept 300 cells (9%) of type 10x-Chromium-v2_Mixture1.
		  # Kept 300 cells (9%) of type 10x-Chromium-v2_Mixture2.
		  # Kept 300 cells (84%) of type CEL-Seq2_Mixture1.
		  # Kept 300 cells (86%) of type CEL-Seq2_Mixture2.
		  # Kept 300 cells (12%) of type Drop-seq_Mixture1.
		  # Kept 300 cells (8%) of type Drop-seq_Mixture2.
		  # Kept 300 cells (10%) of type inDrops_Mixture1.
		  # Kept 300 cells (12%) of type inDrops_Mixture2.
		  # Kept 299 cells (100%) of type sci-RNA-seq_Mixture1.
		  # Kept 300 cells (6%) of type sci-RNA-seq_Mixture2.
		  # Kept 300 cells (18%) of type Seq-Well_Mixture1.
		  # Kept 300 cells (30%) of type Seq-Well_Mixture2.
		  # Kept 300 cells (88%) of type Smart-seq2_Mixture1.
		  # Kept 300 cells (87%) of type Smart-seq2_Mixture2.
		  # Kept 4199 (15.2%) of 27714 cells in 14 blocks.

		  saveRDS(downsampled, file="barnyard_umi_sample.rds") 
		  # online at https://ttriche.github.io/RDS/barnyard_umi_sample.rds

		} 

		```
		</details>

		<p>Right then, let’s get to work. You might consider running through some of the 
		steps in the <a href="http://www.bioconductor.org/packages/release/bioc/vignettes/tidySingleCellExperiment/inst/doc/introduction.html">tidySingleCellExperiment vignette</a> to start with.  If your laptop or Rstudio Cloud instance still blows up, let 
		me know and I’ll create some smaller-er downsamples (also a familiar practice).</p>

		<details>
		  <summary>Load the necessary packages</summary>


		```r

		# need to install from Bioconductor, 
		# unless we're going to dork around with individual genes right from the start
		library(SingleCellExperiment) 
		library(tidySingleCellExperiment)
		```
		</details>

		<p>How the experiment object is created, or (faster) loaded from a URL:</p>

		<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="kc">FALSE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1"># if you want to recreate the SingleCellExperiment: </span><span class="w">

		  </span><span class="n">downsampled</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> 
			</span><span class="n">readRDS</span><span class="p">(</span><span class="n">url</span><span class="p">(</span><span class="s2">"https://ttriche.github.io/RDS/barnyard_umi_sample.rds"</span><span class="p">))</span><span class="w">

		  </span><span class="c1"># create the column (cell) annotation data frame</span><span class="w">
		  </span><span class="n">column_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as</span><span class="p">(</span><span class="n">celltibble</span><span class="p">,</span><span class="w"> </span><span class="s2">"DataFrame"</span><span class="p">)</span><span class="w">
		  </span><span class="n">rownames</span><span class="p">(</span><span class="n">column_data</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">column_data</span><span class="o">$</span><span class="n">name</span><span class="w">
		  </span><span class="n">column_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">column_data</span><span class="p">[</span><span class="n">colnames</span><span class="p">(</span><span class="n">downsampled</span><span class="p">),</span><span class="w"> </span><span class="p">]</span><span class="w">

		  </span><span class="c1"># create the row (gene) annotation data frame</span><span class="w">
		  </span><span class="n">row_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as</span><span class="p">(</span><span class="n">genetibble</span><span class="p">,</span><span class="w"> </span><span class="s2">"DataFrame"</span><span class="p">)</span><span class="w">
		  </span><span class="n">rownames</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">row_data</span><span class="o">$</span><span class="n">name</span><span class="w">
		  </span><span class="n">row_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">row_data</span><span class="p">[</span><span class="n">rownames</span><span class="p">(</span><span class="n">downsampled</span><span class="p">),</span><span class="w"> </span><span class="p">]</span><span class="w">

		  </span><span class="c1"># create a SingleCellExperiment</span><span class="w">
		  </span><span class="n">barnyard</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SingleCellExperiment</span><span class="p">(</span><span class="n">SimpleList</span><span class="p">(</span><span class="n">counts</span><span class="o">=</span><span class="n">downsampled</span><span class="p">),</span><span class="w">
										   </span><span class="n">rowData</span><span class="o">=</span><span class="n">row_data</span><span class="p">,</span><span class="w"> 
										   </span><span class="n">colData</span><span class="o">=</span><span class="n">column_data</span><span class="p">)</span><span class="w">
		  </span><span class="n">saveRDS</span><span class="p">(</span><span class="n">barnyard</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="o">=</span><span class="s2">"barnyard.rds"</span><span class="p">)</span><span class="w"> 

		</span><span class="p">}</span><span class="w">

		</span><span class="c1"># if you just want to load it </span><span class="w">
		</span><span class="n">tidybarnyard</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tidy</span><span class="p">(</span><span class="n">readRDS</span><span class="p">(</span><span class="n">url</span><span class="p">(</span><span class="s2">"https://ttriche.github.io/RDS/barnyard.rds"</span><span class="p">)))</span><span class="w">
		</span><span class="c1">#&gt; Loading required package: SingleCellExperiment</span><span class="w">
		</span><span class="c1">#&gt; Loading required package: SummarizedExperiment</span><span class="w">
		</span><span class="c1">#&gt; Loading required package: GenomicRanges</span><span class="w">
		</span><span class="c1">#&gt; Loading required package: BiocGenerics</span><span class="w">
		</span><span class="c1">#&gt; Error in .requirePackage(package): unable to find required package 'SingleCellExperiment'</span><span class="w">
		</span><span class="n">show</span><span class="p">(</span><span class="n">tidybarnyard</span><span class="p">)</span><span class="w">
		</span><span class="c1">#&gt; Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'show': object 'tidybarnyard' not found</span><span class="w">
		</span></code></pre></div></div>

		<p>I’d suggest, as a first pass, trying to sort out which are the mouse 3T3 cells,
		and which are the human HEK293 cells. We can discuss this in class on Monday.</p>

		<p><em>Question: What’s the easiest way to distinguish the mouse and human cells?</em></p>

		<details>
		  <summary>Hint:</summary>


		```r

		library(tidySingleCellExperiment) 
		rowGenome &lt;- rowData(tidybarnyard)$genome
		UMIs &lt;- counts(tidybarnyard) 

		```
		</details>

		<p><em>Question: Can you think of a way to distinguish male from female cells?</em></p>

		<details>
		  <summary>Hint:</summary>


		```r

		# this requires a bit of domain knowledge, to be added

		```
		</details>

		<p><em>Question: Are the two answers above roughly equivalent?  Why?</em></p>

		<p>Bonus points if you can say where the two cell lines originally came from, and 
		why the HEK cells don’t have the usual PHI-non-compliant names from that time.</p>

		<h1 id="class-exercises">Class exercises</h1>

		<p><em>Question: what is a UMI and why does it matter in single-cell RNAseq data?</em></p>

		<p>Load up either the UMI matrix or the SingleCellExperiment (tidy or untidy) and 
		look for the <code class="language-plaintext highlighter-rouge">counts</code> assay.  (You may need to just use <code class="language-plaintext highlighter-rouge">counts(tidysce)</code>.) If 
		your computer survives neither of these, you can try using summary statistics, 
		but plan on getting an even smaller subsample to use for the actual Project.</p>

		<p>Or, just go back and look at the BUStools figure.</p>

		<p><em>Question: what shall we investigate for project 2?</em></p>

		<p>I’m thinking the proportions of the mixtures, but I want to fit those first. 
		Note that a t-test on proportions is not necessarily “proper”… !</p>

		  </div>

		</article>
		</div>
	

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha384-nvAa0+6Qg9clwYCGGPpDQLVpLNn0fRaROjHqs13t4Ggj3Ez50XnGQqc/r8MhnRDZ" crossorigin="anonymous"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js" integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd" crossorigin="anonymous"></script>
  </body>
</html>